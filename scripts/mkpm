#!/bin/sh -e
# Part of measurement-kit <https://measurement-kit.github.io/>.
# Measurement-kit is free software. See AUTHORS and LICENSE for more
# information on the copying conditions.

COLOR_BLUE="\033[1;34m"
COLOR_GREEN="\033[1;32m"
COLOR_PURPLE="\033[1;35m"
COLOR_RED="\033[1;31m"
COLOR_RESET="\033[0m"
COLOR_YELLOW="\033[1;33m"

echo_blue() {
    first=$1
    shift
    echo "${COLOR_BLUE}${first}${COLOR_RESET}" "$@" 1>&2
}
echo_green() {
    first=$1
    shift
    echo "${COLOR_GREEN}${first}${COLOR_RESET}" "$@" 1>&2
}
echo_red() {
    first=$1
    shift
    echo "${COLOR_RED}${first}${COLOR_RESET}" "$@" 1>&2
}
echo_purple() {
    first=$1
    shift
    echo "${COLOR_PURPLE}${first}${COLOR_RESET}" "$@" 1>&2
}
echo_purple_ifset() {
    [ -z "$2" ] || { echo_purple "$@" 1>&2; }
}
echo_yellow() {
    first=$1
    shift
    echo "${COLOR_YELLOW}${first}${COLOR_RESET}" "$@" 1>&2
}

echo_phase() {
    echo_blue "->" "$@"
}
exec_cmd() {
    echo_green "*" "$@"
    "$@"
}
exec_make_cmd() {
    echo_yellow "build_cmd:" "$@"
    "$@"
}
usage() {
    echo_red "usage:" "$@" 1>&2
    exit 1
}

# When cross building MODULES_DIR is exported by the cross script
if [ -z "$MODULES_DIR" ]; then
    MODULES_DIR=`pwd`/mk_modules
fi

BUILD_CMD=exec_cmd
CURL="curl -# $CURL_FLAGS"
GIT_APPLY="git apply $GIT_APPLY_FLAGS"
GIT_CLONE="git clone $GIT_CLONE_FLAGS"
GITHUB=https://github.com
MKPM_GITHUB_RAW=https://raw.githubusercontent.com/bassosimone/mkpm
BUILT_CACHE=$MODULES_DIR/.built-cache
SPEC_CACHE=$MODULES_DIR/.spec-cache

mkpm_apply_patch() {
    $BUILD_CMD $CURL -O $MKPM_GITHUB_RAW/master/spec/$1
    $BUILD_CMD $GIT_APPLY $1
}
mkpm_clone() {
    $BUILD_CMD $GIT_CLONE --depth=8 "$@"
}

setup_environment_vars() {
    export PREFIX="$MODULES_DIR/.dist"
    echo_purple_ifset "MODULES_DIR" "$MODULES_DIR"
    echo_purple_ifset "BUILD_CACHE" "$BUILD_CACHE"
    echo_purple_ifset "SPEC_CACHE" "$SPEC_CACHE"
    export PATH="$PREFIX/bin:$PATH"
    export CPPFLAGS="$CPPFLAGS -I$PREFIX/include"
    export LDFLAGS="$LDFLAGS -L$PREFIX/lib"
    # Make sure the paths below exist even if they are empty
    exec_cmd install -d $PREFIX/bin
    exec_cmd install -d $PREFIX/include
    exec_cmd install -d $PREFIX/lib
    test -z "$CC" && CC=cc
    test -z "$CXX" && CXX=c++
    test -z "$CXXFLAGS" && CXXFLAGS="-Wall"
    test -z "$CFLAGS" && CFLAGS="-Wall"
    echo_purple_ifset "CC:" "$CC"
    echo_purple_ifset "CFLAGS:" "$CFLAGS"
    echo_purple_ifset "CONFIGURE_FLAGS:" "$CONFIGURE_FLAGS"
    echo_purple_ifset "CPPFLAGS:" "$CPPFLAGS"
    echo_purple_ifset "CXX:" "$CXX"
    echo_purple_ifset "CXXFLAGS:" "$CXXFLAGS"
    echo_purple_ifset "DESTDIR:" "$DESTDIR"
    echo_purple_ifset "LDFLAGS:" "$LDFLAGS"
    echo_purple_ifset "MAKE_FLAGS:" "$MAKE_FLAGS"
    echo_purple_ifset "MKPM_CROSS:" "$MKPM_CROSS"
    echo_purple_ifset "PATH:" "$PATH"
    echo_purple_ifset "PREFIX:" "$PREFIX"
    echo_purple_ifset "pkg_branch:" "$pkg_branch"
    echo_purple_ifset "pkg_deps:" "$pkg_deps"
    echo_purple_ifset "pkg_name:" "$pkg_name"
    echo_purple_ifset "pkg_repo:" "$pkg_repo"
}

pkg_depend() {
    echo_purple_ifset "$pkg_name dependencies:" "$pkg_deps"
    for name in $pkg_deps; do
        $BUILD_CMD $0 install -r $name
    done
}
pkg_clone() {
    $BUILD_CMD cd $MODULES_DIR
    if [ ! -z "$pkg_repo" ]; then
        if [ ! -z "$pkg_branch" ]; then
            pkg_branch="--branch=$pkg_branch"
        fi
        if [ -d $pkg_name ]; then
            $BUILD_CMD rm -rf $pkg_name
        fi
        mkpm_clone $pkg_branch $pkg_repo $pkg_name
    fi
}
pkg_configure() {
    $BUILD_CMD cd $MODULES_DIR/$pkg_name
    if [ -x ./autogen.sh ]; then
        $BUILD_CMD ./autogen.sh
    elif [ -f Makefile.am -o -f configure.ac ]; then
        $BUILD_CMD autoreconf -i
    fi
    if [ -x configure ]; then
        $BUILD_CMD ./configure --prefix=$PREFIX $CONFIGURE_FLAGS
    fi
}
pkg_make() {
    $BUILD_CMD cd $MODULES_DIR/$pkg_name
    if [ -f Makefile ]; then
        $BUILD_CMD make $MAKE_FLAGS
    fi
}
pkg_make_install() {
    $BUILD_CMD cd $MODULES_DIR/$pkg_name
    if [ -f Makefile ]; then
        $BUILD_CMD make $MAKE_FLAGS install
    fi
}

cmd_shell() {
    args=`getopt d:f $@` || {
        usage "$0 shell [-d modules-dir] [--] [configure-args]"
    }
    set -- $args
    while [ $# -gt 0 ]; do
        case "$1" in
            -d) MODULES_DIR=$2; shift; shift;;
            --) shift; break;;
        esac
    done
    setup_environment_vars
    exec_cmd "$@"
}

cmd_install() {
    original_args="$@"
    phases=""
    do_depend=""
    cross=""
    args=`getopt c:d:rx: $@` || {
        usage "mkpm install [-r] [-c clone|configure|make|make_install]\n"     \
              "\t\t    [-d outdir] [-x ios[:arch]|...] package..."
    }
    set -- $args
    while [ $# -gt 0 ]; do
        case "$1" in
            -c) phases="$phases $2"; shift; shift;;
            -d) MODULES_DIR=$2; shift; shift;;
            -r) do_depend="depend"; shift;;
            -x) cross="$2"; shift; shift;;
            --) shift; break;;
        esac
    done
    if [ $# -eq 0 ]; then
        usage "mkpm install [-r] [-c clone|configure|make|make_install]\n"     \
              "\t\t    [-d outdir] [-x ios[:arch]|...] package..."
    fi
    if [ "$cross" != "" -a "$MKPM_CROSS" = "" ]; then
        if echo "$cross" | grep -q ":"; then
            cross_arch="-a `echo $cross | sed 's/^.*://g'`"
            cross=`echo $cross | sed 's/:.*//g'`
        fi
        export MKPM_CROSS="$cross"
        # Basically, re-download the cross-compile script every time
        $BUILD_CMD rm -rf $BUILT_CACHE/mkpm-cross-$cross
        $BUILD_CMD $0 install -r mkpm-cross-$cross
        $BUILD_CMD $MODULES_DIR/.dist/bin/mkpm-cross-$cross cross $cross_arch  \
                   -- $0 install "$original_args"
        $BUILD_CMD exit 0
    fi
    if [ -z "$phases" ]; then
        phases="$do_depend clone configure make make_install"
    fi
    while [ $# -gt 0 ]; do
        spec_or_name=$1; shift
        echo_blue "# install" $spec_or_name
        # Execute in a subshell to avoid polluting environment
        (
            echo_yellow "## setup_environment_vars"
            setup_environment_vars
            echo_yellow "## fetch_spec"
            if echo $spec_or_name | grep -vq '\.spec$'; then
                $BUILD_CMD install -d $SPEC_CACHE
                $BUILD_CMD $CURL -o $SPEC_CACHE/$spec_or_name.spec             \
                    $MKPM_GITHUB_RAW/master/spec/$spec_or_name.spec
                $BUILD_CMD . $SPEC_CACHE/$spec_or_name.spec
            else
                $BUILD_CMD . $spec_or_name
            fi
            if [ -f $BUILT_CACHE/$pkg_name ]; then
                echo_red "warn:" "$pkg_name already built successfully"
                echo_blue "hint:" "do 'rm $BUILT_CACHE/$pkg_name' to remove it"
                exit 0
            fi
            $BUILD_CMD install -d $MODULES_DIR/$pkg_name
            for phase in $phases; do
                echo_yellow "## pkg_$phase"
                # Execute every phase in a subshell not to mess with $CWD
                (pkg_$phase)
            done
            install -d $BUILT_CACHE
            touch $BUILT_CACHE/$pkg_name
        )
    done
}

cmd_scaffolding() {
    args=`getopt f $@` || {
        usage "$0 scaffolding [-f]"
        exit 1
    }
    set -- $args
    while [ $# -gt 0 ]; do
        case "$1" in
            -f) force="yes"; shift;;
            --) shift; break;;
        esac
    done
    if [ $# -ne 0 ]; then
        usage "$0 scaffolding [-f]"
        exit 1
    fi
    if [ -f Makefile.am -a "$force" != "yes" ]; then
        echo_red "fatal" "it seems you already have scaffolding"
        echo_red "fatal" "in fact, Makefile.am is already in your working dir"
        echo_yellow "hint" "use -f flag to force downloading scaffolding"
        exit 1
    fi

    echo_phase "Download stub files"
    for name in Doxyfile.in Makefile.am configure.ac .clang-format \
                .gitignore .travis.yml autogen.sh; do
        exec_cmd curl -sO $MKPM_GITHUB_RAW/master/stub/$name
    done
    exec_cmd chmod +x autogen.sh
    for name in m4/mkpm.m4 scripts/mkpm_new; do
        dirname=`dirname $name`
        exec_cmd install -d $dirname
        exec_cmd cd $dirname
        exec_cmd curl -sO $MKPM_GITHUB_RAW/master/stub/$name
        exec_cmd cd ..
    done

    echo_phase "Add examples, includes, tests to Makefile.am"

    exec_cmd install -d example
    echo_green "->" "add examples"
    echo "" >> Makefile.am
    for source in `ls example/*.cpp`; do
        binary=`echo $source | sed -e 's|.cpp$||g'`
        slug=`echo $binary | sed -e 's|/|_|g' -e 's|-|_|g'`
        echo_purple "EXAMPLE" "$source"
        echo "${slug}_SOURCES = $source" >> Makefile.am
        echo "if BUILD_EXAMPLES" >> Makefile.am
        echo "    noinst_PROGRAMS += $binary" >> Makefile.am
        echo "endif" >> Makefile.am
        echo "$binary" >> .gitignore
    done

    exec_cmd install -d include/mkok
    echo_green "->" "add headers"
    echo "" >> Makefile.am
    dir="mkok"
    slug=`echo $dir | sed 's|/||g'`
    echo "${slug}includedir = \$(includedir)/$dir" >> Makefile.am
    echo "${slug}include_HEADERS = # Empty" >> Makefile.am
    for file in `ls include/$dir/*.hpp`; do
        echo_purple "HEADER" "$file"
        echo "${slug}include_HEADERS += $file" >> Makefile.am
    done

    exec_cmd install -d test
    echo_green "->" "add tests"
    echo "" >> Makefile.am
    for source in `ls test/*.cpp`; do
        binary=`echo $source | sed -e 's|.cpp$||g'`
        slug=`echo $binary | sed -e 's|/|_|g' -e 's|-|_|g'`
        echo_purple "TEST" "$source"
        echo "${slug}_SOURCES = $source" >> Makefile.am
        echo "if BUILD_TESTS" >> Makefile.am
        echo "    check_PROGRAMS += $binary" >> Makefile.am
        echo "    TESTS += $binary" >> Makefile.am
        echo "endif" >> Makefile.am
        echo "$binary" >> .gitignore
    done

    # Handle self update. This must be done at the end.
    test -f scripts/mkpm_new || exit 0
    echo_phase "Self update"
    exec_cmd chmod +x scripts/mkpm_new
    echo_green "cmd:" "exec mv scripts/mkpm_new scripts/mkpm"
    exec mv scripts/mkpm_new scripts/mkpm
}

if [ $# -gt 0 ]; then
    command=$1
    shift
fi

if [ "$command" = "install" ]; then
    cmd_install "$@"
elif [ "$command" = "scaffolding" ]; then
    cmd_scaffolding "$@"
elif [ "$command" = "shell" ]; then
    cmd_shell "$@"
else
    usage "$0 install|scaffolding|shell [options]"
fi
