#!/bin/sh -e
# Part of measurement-kit <https://measurement-kit.github.io/>.
# Measurement-kit is free software. See AUTHORS and LICENSE for more
# information on the copying conditions.

COLOR_BLUE="\033[1;34m"
COLOR_GREEN="\033[1;32m"
COLOR_PURPLE="\033[1;35m"
COLOR_RED="\033[1;31m"
COLOR_RESET="\033[0m"
COLOR_YELLOW="\033[1;33m"

BUILD_FILE=MKBUILD
CONFIG_FILE=mkpm-install.conf
DIST_DIR_NAME=.mk-dist
GITHUB_RAW=https://raw.githubusercontent.com/bassosimone/mkpm
MODULES_DIR=`pwd`/mk_modules

echo_blue() {
    first=$1
    shift
    echo "${COLOR_BLUE}${first}${COLOR_RESET}" "$@"
}
echo_green() {
    first=$1
    shift
    echo "${COLOR_GREEN}${first}${COLOR_RESET}" "$@"
}
echo_red() {
    first=$1
    shift
    echo "${COLOR_RED}${first}${COLOR_RESET}" "$@"
}
echo_purple() {
    first=$1
    shift
    echo "${COLOR_PURPLE}${first}${COLOR_RESET}" "$@"
}
echo_purple_ifset() {
    [ -z "$2" ] || echo_purple "$@"
}
echo_yellow() {
    first=$1
    shift
    echo "${COLOR_YELLOW}${first}${COLOR_RESET}" "$@"
}

echo_phase() {
    echo_blue "->" "$@"
}

exec_cmd() {
    echo_green "cmd:" "$@"
    "$@"
}

exec_build_cmd() {
    echo_yellow "build_cmd:" "$@"
    "$@"
}

usage() {
    echo_red "usage:" "$@" 1>&2
    exit 1
}

pkg_start_over() {
    exec_build_cmd rm -rf $pkgname
}
pkg_clone() {
    if [ ! -z "$pkgtag" ]; then
        pkgtag="--branch=$pkgtag"
    fi
    exec_build_cmd git clone -q --depth=8 $pkgtag $pkgrepo $pkgname
}
pkg_prepare() {
    exec_build_cmd cd $pkgname
    exec_build_cmd autoreconf -i
    exec_build_cmd ./configure --prefix=/ $CONFIGURE_FLAGS $pkg_CONFIGURE_FLAGS
}
pkg_build() {
    exec_build_cmd cd $pkgname
    exec_build_cmd make $MAKE_FLAGS $pkg_MAKE_FLAGS
}
pkg_package() {
    exec_build_cmd cd $pkgname
    exec_build_cmd make $MAKE_FLAGS $pkg_MAKE_FLAGS install DESTDIR=$DESTDIR
}

cmd_configure() {
    args=`getopt d:f $@` || {
        usage "$0 configure [-d modules-dir] [--] [configure-args]"
    }
    set -- $args
    while [ $# -gt 0 ]; do
        case "$1" in
            -d) MODULES_DIR=$2; shift; shift;;
            --) shift; break;;
        esac
    done
    export DESTDIR=$MODULES_DIR/.dist
    exec_cmd install -d $DESTDIR/include
    exec_cmd install -d $DESTDIR/lib
    export CPPFLAGS="$CPPFLAGS -I$DESTDIR/include"
    export LDFLAGS="$LDFLAGS -L$DESTDIR/lib"
    exec_cmd ./configure "$@"
}

cmd_install() {
    args=`getopt d:f $@` || {
        usage "$0 install [-f] [-d modules-dir] package..."
        exit 1
    }
    set -- $args
    while [ $# -gt 0 ]; do
        case "$1" in
            -d) MODULES_DIR=$2; shift; shift;;
            -f) force="yes"; shift;;
            --) shift; break;;
        esac
    done
    if [ $# -eq 0 ]; then
        if [ ! -f $CONFIG_FILE ]; then
            echo_red "fatal" "missing config file: $CONFIG_FILE"
            exit 1
        fi
        set -- `cat $CONFIG_FILE`
    fi
    while [ $# -gt 0 ]; do
        spec_or_name=$1; shift
        # Execute in a subshell to avoid polluting environment
        (
            if echo $spec_or_name | grep -vq '\.spec$'; then
                echo_blue "fetch-spec-by-name" $spec_or_name
                exec_cmd install -d $MODULES_DIR/.spec-cache
                exec_cmd cd $MODULES_DIR/.spec-cache
                exec_cmd curl -sO $GITHUB_RAW/master/spec/$spec_or_name.spec
                exec_cmd cd -
                # Changing directory before sourcing the spec file is necessary
                # for dash (Debian/Ubuntu's /bin/sh) to see the file (why?)
                exec_cmd . $MODULES_DIR/.spec-cache/$spec_or_name.spec
            else
                exec_cmd . $spec_or_name
            fi
            echo_blue "install-spec" $pkgname
            if [ -d $MODULES_DIR/$pkgname -a "$force" != "yes" ]; then
                echo_red "warn:" "already installed: $pkgname"
                continue
            fi
            export DESTDIR=$MODULES_DIR/.dist
            exec_cmd install -d $DESTDIR/include
            exec_cmd install -d $DESTDIR/lib
            export CPPFLAGS="$CPPFLAGS -I$DESTDIR/include"
            export LDFLAGS="$LDFLAGS -L$DESTDIR/lib"
            echo_purple_ifset "CC:" "$CC"
            echo_purple_ifset "CFLAGS:" "$CFLAGS"
            echo_purple_ifset "CONFIGURE_FLAGS:" "$CONFIGURE_FLAGS"
            echo_purple_ifset "CPPFLAGS:" "$CPPFLAGS"
            echo_purple_ifset "CXX:" "$CXX"
            echo_purple_ifset "CXXFLAGS:" "$CXXFLAGS"
            echo_purple_ifset "DESTDIR:" "$DESTDIR"
            echo_purple_ifset "LDFLAGS:" "$LDFLAGS"
            echo_purple_ifset "MAKE_FLAGS:" "$MAKE_FLAGS"
            echo_purple_ifset "pkg_MAKE_FLAGS:" "$pkg_MAKE_FLAGS"
            echo_purple_ifset "pkg_CONFIGURE_FLAGS:" "$pkg_CONFIGURE_FLAGS"
            # Execute each phase in isolation in a distinct subshell
            exec_cmd install -d $MODULES_DIR/$pkgname
            exec_cmd cd $MODULES_DIR/$pkgname
            (exec_cmd pkg_start_over)
            (exec_cmd pkg_clone)
            (exec_cmd pkg_prepare)
            (exec_cmd pkg_build)
            (exec_cmd pkg_package)
        )
    done
}

cmd_init() {
    if [ $# -ne 0 ]; then
        usage "$0 init"
    fi

    echo_phase "Download stub files"
    for name in Doxyfile.in Makefile.am configure.ac .clang-format \
                .gitignore .travis.yml mkpm-install.conf autogen.sh; do
        exec_cmd curl -sO $GITHUB_RAW/master/stub/$name
    done
    exec_cmd chmod +x autogen.sh
    for name in m4/mkpm.m4 scripts/mkpm_new; do
        dirname=`dirname $name`
        exec_cmd install -d $dirname
        exec_cmd cd $dirname
        exec_cmd curl -sO $GITHUB_RAW/master/stub/$name
        exec_cmd cd ..
    done

    echo_phase "Add examples, includes, tests to Makefile.am"

    exec_cmd install -d example
    echo "    \033[1;32m->\033[0m" "add examples"
    echo "" >> Makefile.am
    for source in `ls example/*.cpp`; do
        binary=`echo $source | sed -e 's|.cpp$||g'`
        slug=`echo $binary | sed -e 's|/|_|g' -e 's|-|_|g'`
        echo "        \033[1;35mEXAMPLE\033[0m:" "$source"
        echo "${slug}_SOURCES = $source" >> Makefile.am
        echo "if BUILD_EXAMPLES" >> Makefile.am
        echo "    noinst_PROGRAMS += $binary" >> Makefile.am
        echo "endif" >> Makefile.am
        echo "$binary" >> .gitignore
    done

    exec_cmd install -d include/mkok
    echo "    \033[1;32m->\033[0m" "add headers"
    echo "" >> Makefile.am
    dir="mkok"
    slug=`echo $dir | sed 's|/||g'`
    echo "${slug}includedir = \$(includedir)/$dir" >> Makefile.am
    echo "${slug}include_HEADERS = # Empty" >> Makefile.am
    for file in `ls include/$dir/*.hpp`; do
        echo "        \033[1;35mHEADER\033[0m:" "$file"
        echo "${slug}include_HEADERS += $file" >> Makefile.am
    done

    exec_cmd install -d test
    echo "    \033[1;32m->\033[0m" "add tests"
    echo "" >> Makefile.am
    for source in `ls test/*.cpp`; do
        binary=`echo $source | sed -e 's|.cpp$||g'`
        slug=`echo $binary | sed -e 's|/|_|g' -e 's|-|_|g'`
        echo "        \033[1;35mTEST\033[0m:" "$source"
        echo "${slug}_SOURCES = $source" >> Makefile.am
        echo "if BUILD_TESTS" >> Makefile.am
        echo "    check_PROGRAMS += $binary" >> Makefile.am
        echo "    TESTS += $binary" >> Makefile.am
        echo "endif" >> Makefile.am
        echo "$binary" >> .gitignore
    done

    # Handle self update. This must be done at the end.
    test -f scripts/mkpm_new || exit 0
    echo_phase "Self update"
    exec_cmd chmod +x scripts/mkpm_new
    echo "    \033[1;32m->\033[0m" "exec mv scripts/mkpm_new scripts/mkpm"
    exec mv scripts/mkpm_new scripts/mkpm
}

if [ $# -gt 0 ]; then
    command=$1
    shift
fi

if [ "$command" = "configure" ]; then
    cmd_configure "$@"
elif [ "$command" = "init" ]; then
    cmd_init "$@"
elif [ "$command" = "install" ]; then
    cmd_install "$@"
else
    usage "$0 configure|init|install [options]"
fi
